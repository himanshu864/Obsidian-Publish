---
title: Modular Inverses
---

import Link from 'next/link'

#concept : <Link href="Math">Math</Link>

The **Multiplicative Inverse** of an integer $a$ is an integer $b$ such that:
$$a \cdot b = 1$$
The **Modular Multiplicative Inverse** of an integer $a$ under [[Modulo]] $m$ is an integer $x$ such that:
$$(a \cdot b) \mod m = 1$$
This means $B$ is Modular Multiplicative Inverse of $A$.

<Callout>
  The Modular Inverse of $a$ under modulo $m$ is denoted as $a^{-1} \mod m$ or
  $a^{-1} \pmod{m}$.
</Callout>

---

## Fermat's Little Theorem (for Prime Modulus $m$):

For any integer $a$ and a prime number $m$ with $gcd(a, m) = 1$
$$ a^{m-1} \equiv 1 \pmod{m} $$
$$i.e.$$
$$a^{m - 1} \mod m = 1$$
Dividing both sides by $a$, we get:
$$ a^{m-2} \equiv a^{-1} \pmod{m} $$
Thus, the modular inverse of $a$ is:
$$ a^{-1} = (a^{m-2}) \% m $$

This can be efficiently computed using **[[Modular Exponentiation]]**.

## Code:

---

```cpp
int mod = 1e9 + 7;

int modExp(int a, int b) // Modular Exponentiation
{
    int ans = 1;
    while (b > 0)
    {
        if (b & 1)
            ans = (ans * 1LL * a) % mod;
        a = (a * 1LL * a) % mod;
        b >>= 1;
    }
    return ans;
}

int modInv(int a) // Modular Inverse
{
	if(gcd(a, mod) > 1)
		return -1;
    return modExp(a, mod - 2);
}
```

- **Time Complexity**: $O(\log(m))$
- **Space Complexity**: $O(1)$

## Applications:

---

1. Solving modular equations:

```math
ax \equiv b \pmod{m} \implies x \equiv b \cdot a^{-1} \pmod{m}
```

2. [[Combinatorics]]:

```math
nCr \mod m = \frac{n!}{r!(n-r)!} \cdot a^{-1} \mod m
```
